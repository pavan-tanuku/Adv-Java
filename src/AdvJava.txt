Advanced JAVA:

-> Abstract methods are used to achieve abstraction in Java.
-> An abstract only contains the method signature and not the method body.
-> An abstract method is declared using the abstract keyword and ***must be implemented by the
    (concrete class)subclass***, if the parent class is declared as abstract and extends the abstract class.
-> An abstract method is declared only in an Abstract class.
-> An abstract class can have both abstract and non-abstract methods.
-> You ***cannot create an instance of an abstract class***,but you can create a reference variable
    of the abstract class type (Dynamic Dispatch:   reference type: Abstract class(Parent),
                                                    object type: (Concrete class or non-abstract class)subclass).
-> An abstract class can have 0(zero) or more abstract methods.
-> If a class cannot implement all the abstract methods of the abstract class,
    then we need to declare the class as abstract, which is another abstract class.

-> inner class:
    - A class which is declared inside the body of another class is called an inner class.
    - An inner class is also called a nested class.
    - To access the inner class, first we need to create the object of the outer class.
    - you can make the inner class as static or non-static.
    syntax:
        class OuterClass {
            // instance variable
            // methods
            class InnerClass {
                // instance variable
                // methods
            }
        }
        public class Test {
            main method {
                OuterClass outer = new OuterClass();
                // accessing the inner class
                OuterClass.InnerClass inner = outer.new InnerCass();
            }
        }
    - when you make the inner class as static, you can access the inner class without creating
        object of the outer class.
        syntax:
            class OuterClass {
                // instance variable
                // methods
                static class InnerClass {
                    // instance variable
                    // methods
                }
            }
            public class Test {
                main method {
                    // accessing the inner class
                    OuterClass.InnerClass inner = new OuterClass.InnerClass();
                }
            }

    - When you make the inner class as static, you cannot make the outer class as static.

-> When Reference type != Object type:
    Thing:                                      Decided by:
    - Method availability                       Reference type
    - Overridden method execution               Object type


-> Down-casting and Upcasting doubts:
    - Parent a = new Parent(); // the object type is Parent, If
        Child c = (Child) a; // it will compile but get the ClassCastException at runtime. Because
        the object type is Parent, if we cast it to Child type, it will throw the ClassCastException.

    - the down-cast can be done only when the object type is the Child.
    - When we create the object as upcasting, we can do the down-casting, and the object store
        both Parent and Child properties, but the parent memers are accessible by the parent reference,
        because it will be decided by the compiler. When there is a overridden method,
        the method execution will be decided by the object type at runtime.(runtime polymorphism).
        Parent a = new Child(); // upcasting
        Child c = (Child) a; // down-casting


-> Anonymous inner class:
    - An anonymous inner class is a class which is declared without a name and it is created
        when the object of the class is created.
    - An anonymous inner class is used to provide the implementation of an interface or to extend a class.
    - when we are creating a class only to provide the override the method (includes interface method
        which implementation class) it will create a another class file, so to avoid that we can use
        anonymous inner class.
    syntax:
    // to avoid the extends class file creation and not for only one method
        we can create any methods in the anonymous inner class.
    class Parent {
        void method() {
            System.out.println("Parent method");
        }
    }
    public class Test {
        public static void main(String[] args) {
            Parent p = new Parent() { // anonymous inner class
                void method() {
                    System.out.println("Child method");
                }
            };
            p.method(); // it will call the overridden method of the anonymous inner class.
        }
    }

    // to avoid the implementation class file creation
    interface A {
        void method();
    }
    public class Test {
        public static void main(String[] args) {
            A a = new A() { // anonymous inner class
                // here we are creating not object of A class, we are creating the object
                    of the anonymous inner class which is implementing the A interface.
                public void method() {
                    System.out.println("Implementation of method");
                }
            };
            a.method(); // it will call the implemented method of the anonymous inner class.
        }
    }

-> Interface:
    - If we write the only abstract methods in abstract class, then instead of using the
        abstract class, we can use the interface.
    - An interface is not a class.
    - In interface, by default the all methods are 'public abstract' methods, so
        even we don't write the 'public abstract' keyword, it will be considered as 'public abstract' method.
    - To use the interface, we need to implement the interface in the class by using the
        'implements' keyword.
    - If you don't use all methods in the interface, then you need to declare the class as abstract,
        which is another abstract class and use keyword 'abstract' and 'implements' keyword
        if it implements partial abstract methods from the interface.

    - Every instance variable in the interface is by default 'public static final' variable,
        so even we don't write the 'public static final' keyword, it will be considered as
        'public static final' variable.
    - If the variable ae static, then we can access the variable by using the interface name,
        because static members are accessed by using the class name or interface name.

        example:
        interface Animal {
            void makeSound();
            void eat();
        }

        abstract class Dog implements Animal {
            // Abstract class can implement some methods
            @Override
            public void eat() {
                System.out.println("Dog is eating");
            }
            // makeSound() is not implemented here
        }

        class Labrador extends Dog {
            @Override
            public void makeSound() {
                System.out.println("Woof Woof!");
            }
        }

        public class Main {
            public static void main(String[] args) {
                Animal lab = new Labrador();
                lab.makeSound(); // Woof Woof!
                lab.eat();       // Dog is eating
            }
        }


-> A Class can extend only one class.
-> A Class can implement multiple interfaces.
-> An interface can extend multiple interfaces.
-> An abstract class can implement multiple interfaces, and it can only extend one class.

Need of Interface:
-> Interface is need to generalize the common properties and behaviors of different classes.
    - To develop an application, the developer need computer which performs 'coding', 'testing', etc
        the developer can not depend on laptop only, or desktop only, but both do same work.
        so, we can create an interface 'Computer' which contains the common properties and behaviors
        of the laptop and desktop, and then we can implement the Computer interface in both
        laptop and desktop class, so that we can achieve the abstraction and polymorphism.


-> Enumerations (Enums):
    - An enums are named constants which we create.
    - Instead of creating objects for the class, we can create the objects for the enum,
        because enum is a class.